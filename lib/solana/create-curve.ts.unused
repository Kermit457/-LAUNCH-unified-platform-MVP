/**
 * On-chain Curve Creation for Auto-CCM System
 *
 * Creates a bonding curve on Solana for new users
 * Uses V6 Anchor program: Ej8XrDazXPSRFebCYhycbV1LZGdLHCFddRufRMqZUXQF
 */

import { Program, AnchorProvider, BN } from '@coral-xyz/anchor';
import {
  PublicKey,
  SystemProgram,
  Transaction,
  Connection
} from '@solana/web3.js';
import { connection, CURVE_PROGRAM_ID } from './config';
import { getCurvePDA, getReserveVaultPDA } from './program';
import IDL from '../idl/launchos_curve.json';

/**
 * Config PDA address (needs to be initialized first by admin)
 * This should match your deployed config account
 */
export const CONFIG_SEED = 'config';
export const BAN_LIST_SEED = 'ban_list';

export function getConfigPDA(): PublicKey {
  const [pda] = PublicKey.findProgramAddressSync(
    [Buffer.from(CONFIG_SEED)],
    CURVE_PROGRAM_ID
  );
  return pda;
}

export function getBanListPDA(): PublicKey {
  const [pda] = PublicKey.findProgramAddressSync(
    [Buffer.from(BAN_LIST_SEED)],
    CURVE_PROGRAM_ID
  );
  return pda;
}

/**
 * Create a bonding curve on-chain for a user
 * This is called when a new user signs up via Twitter/Privy
 *
 * @param twitterHandle - User's Twitter username (e.g., "elonmusk")
 * @param creatorWallet - User's Solana wallet address
 * @param creatorKeysAmount - Number of keys creator gets (default: 0 for CCM, they buy their own)
 * @returns Transaction to be signed by the user
 */
export async function buildCreateCurveTransaction(
  twitterHandle: string,
  creatorWallet: PublicKey,
  creatorKeysAmount: number = 0 // 0 means creator must buy their own keys
): Promise<Transaction> {

  // Get PDAs
  const curvePDA = getCurvePDA(twitterHandle);
  const reserveVault = getReserveVaultPDA(curvePDA);
  const configPDA = getConfigPDA();
  const banListPDA = getBanListPDA();

  // Check if config PDA is initialized
  console.log('üîç Checking config PDA:', configPDA.toString());
  const configAccount = await connection.getAccountInfo(configPDA);
  if (!configAccount) {
    throw new Error(`Config PDA not initialized. Admin must run 'initialize' instruction first. Config PDA: ${configPDA.toString()}`);
  }
  console.log('‚úÖ Config PDA exists');
  console.log('üì¶ Config data length:', configAccount.data.length, 'bytes');

  // Check if ban list exists (required by deployed program)
  const banListAccount = await connection.getAccountInfo(banListPDA);
  if (!banListAccount) {
    console.warn('‚ö†Ô∏è  BanList PDA not initialized - transaction may fail');
    console.warn('   Admin should run: node scripts/initialize-banlist.mjs');
  }

  // Log all account PDAs for debugging
  console.log('üìç All PDAs for transaction:');
  console.log('  - Curve PDA:', curvePDA.toString());
  console.log('  - Reserve Vault:', reserveVault.toString());
  console.log('  - Config PDA:', configPDA.toString());
  console.log('  - BanList PDA:', banListPDA.toString(), banListAccount ? '‚úÖ' : '‚ùå');
  console.log('  - Creator:', creatorWallet.toString());

  // Build instruction manually to avoid Anchor version mismatch
  // Program built with Anchor 0.30.1, frontend uses 0.32.1

  // Use web3.js TransactionInstruction for compatibility
  const { TransactionInstruction } = await import('@solana/web3.js');

  // Create instruction discriminator for create_curve (snake_case for Rust function name)
  // This is sha256("global:create_curve")[0..8]
  // Calculated: [169, 235, 221, 223, 65, 109, 120, 183]
  const discriminator = Buffer.from([169, 235, 221, 223, 65, 109, 120, 183]);

  // Serialize instruction data using Borsh-compatible encoding
  // Format: [discriminator (8 bytes), twitterHandle (string), creatorKeysAmount (u64), launchTs (Option<i64>)]
  const twitterHandleBytes = Buffer.from(twitterHandle, 'utf-8');
  const twitterHandleLenBytes = Buffer.alloc(4);
  twitterHandleLenBytes.writeUInt32LE(twitterHandleBytes.length, 0);

  const creatorKeysAmountBytes = Buffer.alloc(8);
  new BN(creatorKeysAmount).toArrayLike(Buffer, 'le', 8).copy(creatorKeysAmountBytes);

  // Option<i64> None = 0x00 (discriminant), Some = 0x01 followed by i64
  const launchTsBytes = Buffer.from([0x00]);

  const data = Buffer.concat([
    discriminator,
    twitterHandleLenBytes,
    twitterHandleBytes,
    creatorKeysAmountBytes,
    launchTsBytes
  ]);

  // Build instruction with manual account keys (including ban_list required by deployed program)
  const keys = [
    { pubkey: curvePDA, isSigner: false, isWritable: true },
    { pubkey: reserveVault, isSigner: false, isWritable: true },
    { pubkey: creatorWallet, isSigner: true, isWritable: true },
    { pubkey: configPDA, isSigner: false, isWritable: false },
    { pubkey: banListPDA, isSigner: false, isWritable: false }, // Required by deployed program
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
  ];

  const createCurveIx = new TransactionInstruction({
    keys,
    programId: CURVE_PROGRAM_ID,
    data,
  });

  // Create transaction
  const transaction = new Transaction().add(createCurveIx);

  return transaction;
}

/**
 * Check if a curve already exists on-chain for a Twitter handle
 */
export async function curveExistsOnChain(twitterHandle: string): Promise<boolean> {
  try {
    const curvePDA = getCurvePDA(twitterHandle);

    // Use simple getAccountInfo instead of Anchor to avoid IDL parsing issues
    const accountInfo = await connection.getAccountInfo(curvePDA);

    // If account exists and has data, curve exists
    return accountInfo !== null && accountInfo.data.length > 0;
  } catch (error: any) {
    console.error('Error checking curve existence:', error);
    return false;
  }
}

/**
 * Get the status of a curve (Pending, Active, Frozen, Launched)
 */
export async function getCurveStatus(twitterHandle: string): Promise<'pending' | 'active' | 'frozen' | 'launched' | null> {
  try {
    const curvePDA = getCurvePDA(twitterHandle);
    const anchorProvider = new AnchorProvider(
      connection,
      {} as any,
      { commitment: 'confirmed' }
    );
    const program = new Program(IDL as any, anchorProvider);

    const curveAccount = await program.account.bondingCurve.fetch(curvePDA) as any;

    if (!curveAccount) return null;

    // Parse the status enum
    if ('pending' in curveAccount.status) return 'pending';
    if ('active' in curveAccount.status) return 'active';
    if ('frozen' in curveAccount.status) return 'frozen';
    if ('launched' in curveAccount.status) return 'launched';

    return null;
  } catch (error: any) {
    if (error.message?.includes('Account does not exist')) {
      return null;
    }
    console.error('Error fetching curve status:', error);
    return null;
  }
}

/**
 * Get user's key holdings for a specific curve
 * Returns 0 if user has never bought keys
 */
export async function getUserKeyHoldings(
  twitterHandle: string,
  userWallet: PublicKey
): Promise<number> {
  try {
    const curvePDA = getCurvePDA(twitterHandle);

    // Derive keyHolder PDA
    const [keyHolderPDA] = PublicKey.findProgramAddressSync(
      [
        Buffer.from('key_holder'),
        curvePDA.toBuffer(),
        userWallet.toBuffer(),
      ],
      CURVE_PROGRAM_ID
    );

    const provider = new AnchorProvider(
      connection,
      {} as any,
      { commitment: 'confirmed' }
    );
    const program = new Program(IDL as any, CURVE_PROGRAM_ID, provider);

    const keyHolderAccount = await program.account.keyHolder.fetch(keyHolderPDA) as any;

    if (!keyHolderAccount) return 0;

    return keyHolderAccount.amount.toNumber();
  } catch (error: any) {
    // Account doesn't exist means 0 keys
    if (error.message?.includes('Account does not exist')) {
      return 0;
    }
    console.error('Error fetching key holdings:', error);
    return 0;
  }
}

/**
 * Example usage:
 *
 * // When user signs up with Twitter
 * const transaction = await buildCreateCurveTransaction(
 *   'elonmusk',
 *   userWallet,
 *   0 // Creator gets 0 keys initially - must buy their own
 * );
 *
 * // User signs and sends transaction
 * const signature = await wallet.signAndSendTransaction(transaction);
 *
 * // Wait for confirmation
 * await connection.confirmTransaction(signature);
 *
 * // Now curve exists on-chain in "Pending" status
 * // User must buy 10+ keys to activate it
 */
